<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转】关于回调、异步和Eventloop的理解]]></title>
    <url>%2F2018%2F10%2F01%2F%E3%80%90%E8%BD%AC%E3%80%91%E5%85%B3%E4%BA%8E%E5%9B%9E%E8%B0%83%E3%80%81%E5%BC%82%E6%AD%A5%E5%92%8CEventloop%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[NodeJS有三大核心： CallBack回调 Event事件 Stream流 下面来看看同步回调：123456789101112131415//代码示例1//Foo函数意在接收两个参数，任意类型a，和函数类型cb，在结尾要调用cb()function Foo(a, cb)&#123; console.log(a); // do something else // Maybe get some parameters for cb var param = Math.random(); cb(param);&#125;//定义一个叫CallBack的函数，将作为参数传给Foovar CallBack = function(num)&#123; console.log(num);&#125;//调用FooFoo(2, CallBack); 讲到这里先停一下，大家注意到本文的标题是解读异步、回调和EventLoop，回调之前还有异步呢，这个顺序对于理解很有帮助，可以说理解回调的前提，是理解异步。 说到异步，什么是异步呢？和分布、并行有什么区别？ 回归原始，追根溯源是我们学习编程的好方法，不去想有什么高级的工具和概念，而去想如果我们只有一个浏览器做编译器和一个记事本，用plain JS写一段异步代码，怎么写？不能用事件系统，不能用浏览器特性。 小明：刚才上面那段代码是异步的吗？老袁：当然不是，即便把Foo改为AsyncFoo也不是。这里比较迷惑的是cb(param)是在Foo函数的最后被调用的。小明：好像觉得异步的代码，确实应该在最后调一个callback函数，因为之后的代码不会被执行到了。老袁：异步的一个定义是函数调用不返回原来代码调用处，而cb(params)调用完后，依旧返回到Foo的尾部，即便cb(params)后还有代码，它们也可以被执行到，这是个同步调用。 Plain JS 异步的写法有很多，以经典的为例：1234567891011121314151617181920212223//代码示例2// ====同步的加法function Add(a, b)&#123; return a+b;&#125;Add(1, 2) // =&gt; 3// ====异步的加法function LazyAdd(a)&#123; return function(b)&#123; return a+b; &#125;&#125;var result = LazyAdd(1); // result等于一个匿名函数，实际是闭包//我们的目的是做一个加法，result中保存了加法的一部分，即第一个参数和之后的运算规则，//通过返回一个持有外层参数a的匿名函数构成的闭包保存至变量result中，这部是异步的关键。//极端的情况var result = LazyAdd(1)(2);这种极端情况又不属于异步了，它和同步没有区别。// 现在可以写一些别的代码了 console.log(&apos;wait some time, doing some fun&apos;);// 实际生产中不会这么简单，它可能在等待一些条件成立，再去执行另外一半。result = result(2) // =&gt; 3 上述代码展示了，最简单的异步。我们要强调的事，异步是异步，回调是回调，他俩半毛钱关系都没有。 Ok，下面把代码改一改，看什么叫异步回调：123456789101112131415//代码示例3//注意还是那个Add，精髓也在这里，随后说到function Add(a, b)&#123; return a+b;&#125;//LazyAdd改变了，多了一个参数cbfunction LazyAdd(a, cb)&#123; return function(b)&#123; cb(a, b); &#125;&#125;//将Add传给形参cbvar result = LazyAdd(1, Add)// doing something elseresult = result(2); // =&gt; 3 16这段代码，看似简单，实则并不平凡。小明：这代码给人的第一感觉就是脱裤子放屁，明明一个a+b，先是变成异步的写法就多了很多代码，人都看不懂了，现在的这个加了所谓的“回调”，更啰嗦了，最后得到的结果都是1+2=3，尼玛这不有病吗？ 老袁：你只看到了结果，却不知道为什么人家这么写，这样写为了什么。代码示例2和3中，同样的Add函数，作为参数传到LazyAdd中，此时它是回调。那为什么代码示例1中，Foo中传入的cb不是回调呢？要仔细体会这句话，需要带状态的才叫回调函数，own state，这里通过闭包保存的a就是状态。 小明：我伙呆 老袁：现在再说为什么要有回调，单看输出结果，回调除了啰嗦和难于理解之外没有任何意义。但是！！！现在说吧，CallBack的好处是：保证API不撕裂也就是说，异步是很有需求的，处理的好能使计算效率提高，不至于卡在某处一直等待。但是异步的写法，我们看到了非常难看，把一个加法变成异步，都如此难看，何况其他。那么CallBack的妙处就是“保证API不撕裂”，代码中写到的精髓所在，还是那个Add，对，让程序员在写异步程序的时候，还能够像同步写法那样好理解，Add作为CallBack传入，保证的是Add这个方法好理解，作为API设计中的重要一个环节，保证开发者用起来方便，代码可读性高。 以NodeJS的readFile API为例进一步说明：fs.readFile(filename, [options], callback)有两个必填的参数filename和callbackcallback是实际程序员要写代码的地方，写它的时候假设文件已经读取到了，该怎么写还怎么写，是API历史上的一次大进步。12345//读取文件&apos;etc/passwd&apos;,读取完成后将返回值，传入function(err, data) 这个回调函数。fs.readFile(&apos;/etc/passwd&apos;, function (err, data) &#123; if (err) throw err; console.log(data);&#125;); 回调和闭包有一个共同的特性：在最终“回调 ”调用以前，前面所有的状态都得存着。 这段代码对于人们的疑惑常常是，我怎么知道callback要接收几个参数，参数的类型是什么？答：是API提供者事先设计好的，它需要在文档中说明callback接收什么参数。 如代码3展示的那样，API设计者通过种种技巧，实现了回调的形式，这种种技巧写起来很痛苦。而fs.readFile看起来写的很轻巧，这是因为它不光包含异步、回调，还引入的新的概念EventLoop。 EventLoop是很早前就有的概念，如MFC中的消息循环，浏览器中的事件机制等等。 那为什么要有EventLoop，它的目的是什么呢？ 我们用一个简单的伪示例，看没有EventLoop时是怎么工作：1234567891011121314151617181920212223242526//代码示例4function Add(a, b)&#123; return a+b;&#125;function LazyAdd(a, cb)&#123; return function(b)&#123; cb(a, b); &#125;&#125;var result = LazyAdd(1, Add)// 假设有一个变量button为false，我们继续调用result的条件是，当button为true的时候。var button = false;// 常用的办法是观察者模式，派一个人不断的看button的值，//只要变了就开始执行result(2), 当然得有别人去改变button的值，//这里假设有人有这个能力,比如起了另外一个线程去做。while(true)&#123; if(button)&#123; result = result(2); break; &#125;&#125;result = result(2); // =&gt; 3 所以如果有很多这样的函数，每一个都要跑一个观察者模式，在一定条件下看上去比较费计算。这时EventLoop诞生了，派一个人来轮询所有的，其他人都可以把观察条件和回调函数注册在EventLoop上，它进行统一的轮询，注册的人越多，轮询一圈的时间越长。但是简化了编程，不用每个人都写轮询了，提供API变得方便，就像fs.readFile一样简单明白，fs.readFile读取文件’/etc/passwd’，将其注册到EventLoop上，当文件读取完毕的时候，EventLoop通过轮询感知到它，并调用readFile注册时带的回调函数，这里是funtion(err, data) 换一个说法再说一遍：在特定条件下，单台机器上用空间换计算。原本callback执行了就不等了，存在一个地方，其他依赖它的，用观察着模式一直盯着它，各自轮询各自的。现在有人出来替大家统一轮询。 再换一个说法说一遍，重要的事情，换着方法说3遍：在单台机器上，统一轮询看上去比较省，也带来了很多问题，比如NodeJS中单线程情况下，如果一个函数计算量非常复杂，会阻碍所有其他的事件，所以这种情况要将复杂计算交给其他线程或者是服务来做。我们一直在强调单台机器，如果是多台，用一个统一的人来轮询，就比较恐怖了，大家把事件都注册到一台机器上，它负责轮询所有的，这个namenode就容易崩溃。所以在多台机器上，又适合，每天机器各自轮询各自的，带来的问题是状态不一致了。好的，这才是程序有意思的地方，我们需要知道为什么发明EventLoop，也需要知道EventLoop在什么地方遇到问题。那些天才的程序员，又提出了各种一致性算法来解决这个问题，本文暂不讨论。 到目前为止，我们梳理了他们之间的关系：异步 –&gt; 回调 –&gt; EventLoop每一次进步都是上一个台阶，都需要智慧来解决。 回调还产生了很多问题，最严重的问题是callback hell回调地狱。123456789fs.readFile(&apos;/etc/password&apos;, function(err, data)&#123; // do something fs.readFile(&apos;xxxx&apos;, function(err, data)&#123; //do something fs.readFile(&apos;xxxxx&apos;, function(err, data)&#123; // do something &#125;) &#125;)&#125;)]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】深入之静态作用域和动态作用域]]></title>
    <url>%2F2018%2F08%2F03%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%B7%B1%E5%85%A5%E4%B9%8B%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别：1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设JavaScript采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设JavaScript采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript采用的是静态作用域，所以这个例子的结果是 1。 动态作用域也许你会好奇什么语言是动态作用域？ bash 就是动态作用域，不信的话，把下面的脚本存成例如 scope.bash，然后进入相应的目录，用命令行执行 bash ./scope.bash，看看打印的值是多少。123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个文件也可以在 Github 博客仓库中找到。 思考题最后，让我们看一个《JavaScript权威指南》中的例子：123456789101112131415161718var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f();&#125;checkscope();var scope = &quot;global scope&quot;;function checkscope()&#123; var scope = &quot;local scope&quot;; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为JavaScript采用的是词法作用域，函数的作用域基于函数创建的位置。而引用《JavaScript权威指南》的回答就是：JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 但是在这里真正想让大家思考的是： 虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 如果要回答这个问题，就要牵涉到很多的内容，词法作用域只是其中的一小部分，让我们期待下一篇文章————《JavaScript深入之执行上下文栈》。From: 原文章]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>js作用域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】js深入之原型与原型链]]></title>
    <url>%2F2018%2F08%2F01%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91js%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在逛github的时候发现了一个大神写的关于js的文章，感觉写得很好，由浅入深，对自己帮助很大，所以在这里引载他的文章，供自己和大家学习。 原文链接 构造函数创建对象我们先使用构造函数创建一个对象：123456function Person() &#123;&#125;var person = new Person();person.name = &apos;Kevin&apos;;console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &apos;Kevin&apos;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外) 在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。为了证明这一点,我们可以在火狐或者谷歌中输入：12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。为了验证这一点，我们可以尝试：1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出：12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子：12345678910111213function Person() &#123;&#125;Person.prototype.name = &apos;Kevin&apos;;var person = new Person();person.name = &apos;Daisy&apos;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：123var obj = new Object();obj.name = &apos;Kevin&apos;console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？null，我们可以打印：1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是：null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子：12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：1person.constructor === Person.prototype.constructor ### proto其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的入门与理解]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：1.app.js2.app.json3.app.wxss 而一个小程序页面由四个文件组成的1.js2.wxml3.wxss4.json 二、主文件的配置1.app.js 主要写全局js2.app.json 对小程序进行全局配置，决定页面文件的路径、窗口的显示情况、设置网络超时时间、设置多个tab等。 其中pages接收一个数组，并且每一项代表对应的页面的【路径+文件】，如果要新增一个页面，可以在这里面配置好保存，然后就会自动生成。3.app.wxss 待续……]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令总结（一）]]></title>
    <url>%2F2018%2F06%2F19%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经过一晚上的打滚，总结一下关于git的常用命令。(后期还会更新） 远程仓库与本地仓库关联123456789101112131415161718192021222324252627//一、进入.ssh文件夹。cd ~/.ssh //若没有.ssh文件夹，则使用如下命令创建：mkdir ~/.ssh //二、配置name和emailgit config --global user.name &quot;lkt&quot; git config --global user.email &quot;lkt@temp.com&quot; //将命令中的name和email换成自己的。//三、生成key。ssh-keygen -t rsa -C “lkt@temp.com” //按三次回车，最后在.ssh文件夹下得到id_rsa和id_rsa.pub两个文件。id_rsa中的内容便是私钥，id_rsa.pub中的内容便是公钥。到这里ssh key就生成完毕了。 找到本地的公钥后，登录github，打开setting-ssh keys中，进行配置公钥。之后再通过以下命令实现本地仓库与远程仓库的关联1git remote add origin 仓库地址 git 克隆1234567//在对别人代码进行克隆的时候，可以以下命令：git clone 仓库地址//要是想有选择地克隆对方分支的文件，用这个：git clone -b 分支名称 仓库地址 git add1234//有选择地addgit add + 想要提交的文件名 git add 添加多个文件时，多个文件名之间用空格隔开 创建本地新分支1234567891011git branch 分支名称git checkout 分支名称 //切换本地分支git push origin 分支名 //其中origin指的是远程的仓库git branch -a //查看项目分支们git branch -d 分支名称 //删除本地分支git push origin --delete 分支名称 //删除远程分支 创建gh-pages分支进行项目演示123456git checkout --orphan gh-pages git add . //添加文件到暂存区git commit -m &quot;This is add message&quot; //添加信息，并把暂存区的所有修改提交到分支git push origin 分支名称 //提交到远程分支 合并分支1git merge --no-ff 分支名称 以上是小弟今晚的整理内容，后期有总结还会继续更新。 在简书上看到关于git的多人合作和分支管理，感觉写得很好，有兴趣可以看：传送们]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-xml学习笔记]]></title>
    <url>%2F2018%2F06%2F11%2Fjson-xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我们先来说说json与xml的区别： （1）可读性方面：基本相同，XML的可读性比较好； （2）可扩展性方面：都具有良好的扩展性； （3）编码难度方面：相对而言，JSON的编码比较容易； （4）解码难度：JSON的解码难度基本为零，XML需要考虑子节点和父节点； （5）数据体积方面：JSON相对于XML来讲，数据体积小，传递的速度比较快； （6）数据交互方面：JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互； （7）数据描述方面：XML对数据描述性比较好； （8）传输速度方面：JSON的速度远远快于XML。 一、json学习笔记json的一个简单例子1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125; json的语法规则1、数据在名称/值对中 2、数据由逗号分隔 3、花括号保存对象 4、方括号保存数组 json 名称/值对1&quot;firstName&quot; : &quot;John&quot; json可以包含多个名称和键值对1&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; json的数组1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 把 JSON 文本转换为 JavaScript 对象（1）创建包含json语法的javascript字符串1234var txt = &apos;&#123; &quot;employees&quot; : [&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125; ]&#125;&apos;; （2）使用eval（）函数由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。 eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：1var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); 在网页中使用 JavaScript 对象：123456789&lt;p&gt;First Name: &lt;span id=&quot;fname&quot;&gt;&lt;/span&gt;&lt;br /&gt;Last Name: &lt;span id=&quot;lname&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&quot;fname&quot;).innerHTML = obj.employees[1].firstNamedocument.getElementById(&quot;lname&quot;).innerHTML = obj.employees[1].lastName&lt;/script&gt; 二、xml学习笔记一个XML文档实例1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。 XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。 所有元素均可拥有子元素：12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 上图表示下面的 XML 中的一本书：1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 例子中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、&lt; author&gt;、、。 xml语法规则1、所有 XML 元素都须有关闭标签2、XML 标签对大小写敏感3、XML 必须正确地嵌套4、XML 文档必须有根元素5、XML 的属性值须加引号1234&lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 6、实体引用在 XML 中，一些字符拥有特殊的意义。 如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 这样会产生 XML 错误：在 XML 中，有 5 个预定义的实体引用：7、XML 中的注释在 XML 中编写注释的语法与 HTML 的语法很相似：1&lt;!-- This is a comment --&gt; 8、在 XML 中，空格会被保留 xml命名规则(1.) 名称可以含字母、数字以及其他的字符(2.) 名称不能以数字或者标点符号开始(3.) 名称不能以字符 “xml”（或者 XML、Xml）开始(4.) 名称不能包含空格 XMLHttpRequest 对象什么是 XMLHttpRequest 对象？XMLHttpRequest 对象用于在后台与服务器交换数据。 XMLHttpRequest 对象是开发者的梦想，因为您能够： 在不重新加载页面的情况下更新网页在页面已加载后从服务器请求数据在页面已加载后从服务器接收数据在后台向服务器发送数据 1、创建 XMLHttpRequest 对象所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。 通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。123xmlhttp=new XMLHttpRequest();老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 一个实例:12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type=&quot;text/javascript&quot;&gt;var xmlhttp;function loadXMLDoc(url)&#123;xmlhttp=null;if (window.XMLHttpRequest) &#123;// code for all new browsers xmlhttp=new XMLHttpRequest(); &#125;else if (window.ActiveXObject) &#123;// code for IE5 and IE6 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change; xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(null); &#125;else &#123; alert(&quot;Your browser does not support XMLHTTP.&quot;); &#125;&#125;function state_Change()&#123;if (xmlhttp.readyState==4) &#123;// 4 = &quot;loaded&quot; if (xmlhttp.status==200) &#123;// 200 = OK // ...our code here... &#125; else &#123; alert(&quot;Problem retrieving XML data&quot;); &#125; &#125;&#125;&lt;/script&gt; xml解析器1、通用方法:123456789101112if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;xmlhttp.open(&quot;GET&quot;,&quot;books.xml&quot;,false);xmlhttp.send();xmlDoc=xmlhttp.responseXML; 2、通过微软的 XML 解析器来加载 XML微软的 XML 解析器内建于 Internet Explorer 5 以及更高的版本中。123var xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);xmlDoc.async=&quot;false&quot;;xmlDoc.load(&quot;note.xml&quot;); 3、在 Firefox 及其他浏览器中的 XML 解析器下面的 JavaScript 片段把 XML 文档 (“note.xml”) 载入解析器：123var xmlDoc=document.implementation.createDocument(&quot;&quot;,&quot;&quot;,null);xmlDoc.async=&quot;false&quot;;xmlDoc.load(&quot;note.xml&quot;); 4、解析 XML 字符串1234567891011121314151617txt=&quot;&lt;bookstore&gt;&lt;book&gt;&quot;;txt=txt+&quot;&lt;title&gt;Everyday Italian&lt;/title&gt;&quot;;txt=txt+&quot;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;&quot;;txt=txt+&quot;&lt;year&gt;2005&lt;/year&gt;&quot;;txt=txt+&quot;&lt;/book&gt;&lt;/bookstore&gt;&quot;;if (window.DOMParser) &#123; parser=new DOMParser(); xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;); &#125;else // Internet Explorer &#123; xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); xmlDoc.async=&quot;false&quot;; xmlDoc.loadXML(txt); &#125; xml DOMXML DOM (XML Document Object Model) 定义了访问和操作 XML 文档的标准方法。 DOM 把 XML 文档作为树结构来查看。能够通过 DOM 树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。 在下面的例子中，我们使用 DOM 引用从 元素中获取文本：1xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue xmlDoc -由解析器创建的 XML 文档getElementsByTagName(“to”)[0] - 第一个 元素childNodes[0] - 元素的第一个子元素（文本节点）nodeValue - 节点的值（文本本身） 关于XML HttpRequest的状态码readyState有五种状态： 0 (未初始化)： (XMLHttpRequest)对象已经创建，但还没有调用open()方法； 1 (载入)：已经调用open() 方法，但尚未发送请求； 2 (载入完成)： 请求已经发送完成； 3 (交互)：可以接收到部分响应数据； 4 (完成)：已经接收到了全部数据，并且连接已经关闭。 status实际是一种辅状态判断，只是status更多是服务器方的状态判断。 关于status，由于它的状态有几十种，我只列出平时常用的几种： 1xx——信息类，表示收到Web浏览器请求，正在进一步的处理中。如，100：客户必须继续发出请求；101：客户要求服务器根据请求转换HTTP协议版本 2xx——成功，表示用户请求被正确接收，理解和处理。例如，200：OK；201：提示知道新文件的URL 3xx——重定向，表示请求没有成功，客户必须采取进一步的动作。如，300：请求的资源可在多处得到；301：删除请求数据 4xx——客户端错误，表示客户端提交的请求有错误。如，404：NOT Found，意味着请求中所引用的文档不存在。 5xx——服务器错误，表示服务器不能完成对请求的处理。如，500，服务器产生内部错误]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】全面理解Javascript闭包和闭包的几种写法及用途]]></title>
    <url>%2F2018%2F06%2F06%2F%E3%80%90%E8%BD%AC%E3%80%91%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3Javascript%E9%97%AD%E5%8C%85%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[一、什么是闭包和闭包的几种写法和用法1、什么是闭包 闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 简单的说，Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 2、闭包的几种写法和用法 首先要明白，在JS中一切都是对象，函数是对象的一种。下面先来看一下闭包的5种写法，简单理解一下什么是闭包。后面会具体解释。 1234567891011//第1种写法 function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125; var c = new Circle(1.0); alert(c.area()); 这种写法没什么特别的，只是给函数添加一些属性。 12345678910111213//第2种写法 var Circle = function() &#123; var obj = new Object(); obj.PI = 3.14159; obj.area = function( r ) &#123; return this.PI * r * r; &#125; return obj; &#125; var c = new Circle(); alert( c.area( 1.0 ) ); 这种写法是声明一个变量，将一个函数当作值赋给变量。 12345678//第3种写法 var Circle = new Object(); Circle.PI = 3.14159; Circle.Area = function( r ) &#123; return this.PI * r * r; &#125; alert( Circle.Area( 1.0 ) ); 这种方法最好理解，就是new 一个对象，然后给对象添加属性和方法。 12345678//第4种写法 var Circle=&#123; &quot;PI&quot;:3.14159, &quot;area&quot;:function(r)&#123; return this.PI * r * r; &#125; &#125;; alert( Circle.area(1.0) ); 这种方法使用较多，也最为方便。var obj = {}就是声明一个空的对象。1234//第5种写法 var Circle = new Function(&quot;this.PI = 3.14159;this.area = function( r ) &#123;return r*r*this.PI;&#125;&quot;); alert( (new Circle()).area(1.0) ); 说实话，这种写法我是没用过，大家可以参考一下。 总的来说，上面几种方法，第2中和第4中较为常见，大家可以根据习惯选择。 上面代码中出现了JS中常用的Prototype，那么Prototype有什么用呢？下面我们来看一下： 1234567891011121314151617var dom = function()&#123; &#125;;dom.Show = function()&#123; alert(&quot;Show Message&quot;);&#125;;dom.prototype.Display = function()&#123; alert(&quot;Property Message&quot;);&#125;;dom.Display(); //errordom.Show(); var d = new dom();d.Display();d.Show(); //error 我们首先声明一个变量，将一个函数赋给他，因为在Javascript中每个函数都有一个Portotype属性，而对象没有。添加两个方法，分别直接添加和添加打破Prototype上面，来看下调用情况。分析结果如下： 1、不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！ 2、使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！ 下面我们再来看一段代码： 12345678910var dom = function()&#123; var Name = &quot;Default&quot;; this.Sex = &quot;Boy&quot;; this.success = function()&#123; alert(&quot;Success&quot;); &#125;; &#125;; alert(dom.Name); alert(dom.Sex); 大家先看看，会显示什么呢？ 答案是两个都显示Undefined,为什么呢？这是由于在Javascript中每个function都会形成一个作用域，而这些变量声明在函数中，所以就处于这个函数的作用域中，外部是无法访问的。要想访问变量，就必须new一个实例出来。 123456789var html = &#123; Name:&apos;Object&apos;, Success:function()&#123; this.Say = function()&#123; alert(&quot;Hello,world&quot;); &#125;; alert(&quot;Obj Success&quot;); &#125; &#125;; 再来看看这种写法，其实这是Javascript的一个”语法糖”，这种写法相当于： 1234567var html = new Object();html.Name = &apos;Object&apos;;html.Success = function()&#123; this.Say = function()&#123; alert(&quot;Hello,world&quot;); &#125;; alert(&quot;Obj Success&quot;); 变量html是一个对象，不是函数，所以没有Prototype属性，其方法也都是公有方法，html不能被实例化。否则会出现如下错误： 但是他可以作为值赋给其它变量，如var o = html; 我们可以这样使用它： alert(html.Name); html.Success(); 说到这里，完了吗？细心的人会问，怎么访问Success方法中的Say方法呢？是html.Success.Say()吗？ 当然不是，上面刚说过由于作用域的限制，是访问不到的。所以要用下面的方法访问： 123456789var s = new html.Success();s.Say();//还可以写到外面html.Success.prototype.Show = function()&#123; alert(&quot;HaHa&quot;);&#125;;var s = new html.Success();s.Show(); 关于Javascript作用域的问题，不是一两句能说清楚的，有兴趣的大家可以网上找些资料看看。 二、Javascript闭包的用途事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。 1、匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包： 1234567891011121314var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。 2、结果缓存 我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间， 那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 12345678910111213141516171819202122232425var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(&quot;input&quot;); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 3、封装 123456789101112131415161718192021222324var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(&quot;abruzzi&quot;); print(person.getName()); 得到结果如下： undefined default abruzzi 4、实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person(); p.setName(&quot;Tom&quot;); alert(p.getName()); var Jack = function()&#123;&#125;; //继承自Person Jack.prototype = new Person(); //添加私有方法 Jack.prototype.Say = function()&#123; alert(&quot;Hello,my name is Jack&quot;); &#125;; var j = new Jack(); j.setName(&quot;Jack&quot;); j.Say(); alert(j.getName()); 我们定义了Person，它就像一个类，我们new一个Person对象，访问它的方法。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack初体验]]></title>
    <url>%2F2018%2F06%2F02%2Fwebpack%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[如今，越来越多的JavaScript代码被使用在页面上，我们添加很多的内容在浏览器里。如何去很好的组织这些代码，成为了一个必须要解决的难题。 对于模块的组织，通常有如下几种方法： 通过书写在不同文件中，使用script标签进行加载CommonJS进行加载（NodeJS就使用这种方式）AMD进行加载（require.js使用这种方式）ES6模块 思考：为什么只有JS需要被模块化管理，前台的很多预编译内容，不需要管理吗？ 基于以上的思考，WebPack项目有如下几个目标： 1、将依赖树拆分，保证按需加载2、保证初始加载的速度3、所有静态资源可以被模块化4、可以整合第三方的库和模块5、可以构造大系统6、从下图可以比较清晰的看出WebPack的功能 这是一个示意图WebPack的特点1、丰富的插件，方便进行开发工作2、大量的加载器，包括加载各种静态资源3、代码分割，提供按需加载的能力4、发布工具 WebPack的优势webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。能被模块化的不仅仅是 JS 了。开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。 WebPack的安装安装命令1$ npm install webpack -g 使用webpack12$ npm init # 会自动生成一个package.json文件$ npm install webpack --save-dev #将webpack增加到package.json文件中 可以使用不同的版本1$ npm install webpack@1.2.x --save-dev 如果想要安装开发工具1$ npm install webpack-dev-server --save-dev WebPack的配置每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 下面是一个例子12345678910111213141516171819202122232425262728293031323334353637var webpack = require(&apos;webpack&apos;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : &apos;./src/js/page/index.js&apos; &#125;, //入口文件输出配置 output: &#123; path: &apos;dist/js/page&apos;, filename: &apos;[name].js&apos; &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;, &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;, &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125; ] &#125;, //其它解决方案配置 resolve: &#123; //查找module的话从这里开始查找 root: &apos;E:/github/flux-example/src&apos;, //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : &apos;js/stores/AppStores.js&apos;, ActionType : &apos;js/actions/ActionType.js&apos;, AppAction : &apos;js/actions/AppAction.js&apos; &#125; &#125;&#125;; plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。entry 是页面入口文件配置，output 是对应输出项配置 （即入口文件最终要生成什么名字的文件、存放到哪里）module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。 所有加载器需要使用npm来加载最后是 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写） WebPack开始使用这里有最基本的使用方法，给大家一个感性的认识 正确安装了WebPack，方法可以参考上面书写entry.js文件12345678910document.write(&quot;看看如何让它工作！&quot;);书写index.html文件&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 执行命令，生成bundle.js文件$ webpack ./entry.js bundle.js在浏览器中打开index.html文件，可以正常显示出预期增加一个content.js文件module.exports = “现在的内容是来自于content.js文件！”;修改entry.js文件1document.write(require(&quot;./content.js&quot;)); 执行第四步的命令进行加载器试验 增加style.css文件123body &#123; background: yellow;&#125; 修改entry.js文件12require(&quot;!style-loader!css-loader!./style.css&quot;);document.write(require(&quot;./content.js&quot;)); 执行命令，安装加载器1$ npm install css-loader style-loader # 安装的时候不使用 -g 执行webpack命令，运行看效果可以在命令行中使用loader1$ webpack ./entry.js bundle.js --module-bind &quot;css=style-loader!css-loader&quot; 使用配置文件默认的配置文件为webpack.config.js 增加webpack.config.js文件123456789101112module.exports = &#123; entry: &quot;./entry.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &quot;style-loader!css-loader&quot; &#125; ] &#125;&#125;; 执行程序1$ webpack 发布服务器 安装服务器12$ npm install webpack-dev-server -g$ webpack-dev-server --progress --colors 服务器可以自动生成和刷新，修改代码保存后自动更新画面http://localhost:8080/webpack-dev-server/bundle WebPack常用命令$ webpack –display-error-details后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。1234$ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包$ webpack --watch //监听变动并自动打包$ webpack -p //压缩混淆脚本，这个非常非常重要！$ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 作者：hutou來源：简书]]></content>
      <categories>
        <category>模块打包器</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解浮动以及解决浮动带来的问题]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%90%86%E8%A7%A3%E6%B5%AE%E5%8A%A8%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%B5%AE%E5%8A%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[要解决浮动带来的各种问题，首先我们得了解浮动的特点和造成的问题，方能对症下药。 一、浮动的特点在CSS2.1 规范中，对浮动的解释如下： A float is a box that is shifted to the left or right on the current line. A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float. If there is a line box, the outer top of the floated box is aligned with the top of the current line box. If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present. 浮动元素脱离文档流，在当前行的左边或是右边对齐，如果当前行没有足够的空间，它将下移一行，直到有足够的空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 二、浮动造成的问题（1）父元素的高度无法被撑开 关于这个一点，就不演示了。 （2）浮动元素前同级非浮动元素： 若为：行内元素 当行内元素被撑起的宽度加上浮动元素的宽度，大于父元素的宽度时，浮动元素，就会下移一个line-height，直到计算的值小于父元素的宽度时，非浮动元素会跟随其后，如下： 123456789&lt;div style=&quot; height:500px;background-color:#0f0&quot;&gt; &lt;span style=&quot;background-color:#ff0; line-height:35px;&quot; &gt; 浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离 &lt;/span&gt; &lt;div style=&quot;width:100px; height:500px;background-color:#f00; float:left; display:-inline-block&quot; &gt; &lt;/div&gt; &lt;/div&gt; 若为：块内元素 浮动元素会在块内元素下一行进行浮动。 123456789&lt;div style=" height:500px;background-color:#0f0"&gt; &lt;div style="line-height:35px;" &gt; 浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离 &lt;/div&gt; &lt;div style="width:100px; height:500px;background-color:#f00; float:left;" &gt; &lt;/div&gt; &lt;/div&gt; （3）浮动元素后同级非浮动元素： 无论是行内元素，还是块内元素，都会会紧随浮动元素之后，也就是说同一水平的line boxes都被压缩了，这也是文字环绕图片的原因。但是从黄色边框的div的位置可以看出，其在定位上，并没有受到浮动元素的影响。具体效果如下： 1234567891011121314&lt;div style="background-color:#0f0; border:5px solid #000; padding:10px"&gt; 黑色表框为最外层包裹元素 &lt;div style="width:100px; height:500px;border:1px solid #F00; float:left; color:#F00" &gt; 红色边框的为左浮动元素 &lt;/div&gt; &lt;div style="line-height:35px; width:800px;border:5px solid #FF0; min-height:200px; color:#FF0" &gt; 黄色表框的为这是块内元素 &lt;/div&gt; &lt;span style="line-height:35px; border:5px solid #F0F; color:#F0F" &gt; 黄色表框的为这是行内元素 &lt;/span&gt; &lt;/div&gt; （4）浮动元素对浮动元素的影响 同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面，当空间不够时会被挤下。 反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下。如下： 123456789&lt;div style="background-color:#00f;"&gt; &lt;div style="border:1px solid #F00; width:200px; height:100px;float:left; margin-bottom:5px;"&gt; 浮动box 1 &lt;/div&gt; &lt;/div&gt; &lt;div style="border:1px solid #F00; width:200px; height:100px;float:left; margin-bottom:5px;"&gt; 浮动box 2 &lt;/div&gt; 三、浮动的解决办法目前关于浮动问题的解决办法主要由以下两种： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。如： ①在浮动的元素后面添加一个能构成block-level boxes元素，设置style=”clear:both;”； ②给浮动的父元素添加一个:after伪元素。 1234567891011121314.clearFloat:after &#123; content:""; /*设置该区域的内容*/ display:block; /*把该区域转为block-level boxes 因为clear对该类型的box有效，伪元素:before和:after添加的内容默认是inline元素*/ clear:both; /*清除浮动*/ visibility: hidden; /*不显示该区域,其实上面设置了content为空，这一行可以省略*/ &#125; /*bootstratp3.1.0 中 解决浮动问题的*/ .clearfix:before,.clearfix:after&#123; display: table; content: " " &#125; .clearfix:after&#123; clear: both; &#125; 有的时候，为了兼容IE，还得添加一个.clearfix{*zoom:1}。为什么要使用到before呢？这个是防止margin折叠的，关于margin折叠，可以查看css手册8.3.1 Collapsing margins 二是：利用BFC (Block Formatting Contexts, 块级格式化上下文)特性：:BFC就是页面上的一个隔离的独立容器，不会与其他Box发生折叠（即使元素浮动），容器里面的子元素不会影响到外面的元素，反之也如此。关于这一点，可以“理解CSS中的BFC块级格式化上下文”。如下： 12345div style="background-color:#00f; display:table"&gt; &lt;div style=" width:200px; height:50px; float:left; border:1px solid #f00; "&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="border:1px solid #0Ff ;width:200px; height:50px; margin-top:15px; float:left;"&gt;&lt;/div&gt; 浮动的父元素，通过设置display等于table（当然“理解CSS中的BFC块级格式化上下文”里，还有其他很多方式哦），拥有了BFC，就能解决浮动塌方问题，同时也解决了浮动元素对浮动元素的影响。由于创建BFC方式来解决浮动带来的问题，往往会改变父元素的某些特性，在实际开发中，采用的不是很多。]]></content>
      <categories>
        <category>浮动问题</category>
      </categories>
      <tags>
        <tag>float</tag>
        <tag>浮动问题</tag>
      </tags>
  </entry>
</search>
