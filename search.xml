<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【转载】js深入之原型与原型链]]></title>
    <url>%2F2018%2F08%2F01%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91js%E6%B7%B1%E5%85%A5%E4%B9%8B%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在逛github的时候发现了一个大神写的关于js的文章，感觉写得很好，由浅入深，对自己帮助很大，所以在这里引载他的文章，供自己和大家学习。 原文链接 构造函数创建对象我们先使用构造函数创建一个对象：123456function Person() &#123;&#125;var person = new Person();person.name = &apos;Kevin&apos;;console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。很简单吧，接下来进入正题： prototype每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如：12345678910function Person() &#123;&#125;// 虽然写在注释里，但是你要注意：// prototype是函数才会有的属性Person.prototype.name = &apos;Kevin&apos;;var person1 = new Person();var person2 = new Person();console.log(person1.name) // Kevinconsole.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型”继承”属性。让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。为了证明这一点,我们可以在火狐或者谷歌中输入：12345function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。为了验证这一点，我们可以尝试：1234function Person() &#123;&#125;console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出：12345678910function Person() &#123;&#125;var person = new Person();console.log(person.__proto__ == Person.prototype) // trueconsole.log(Person.prototype.constructor == Person) // true// 顺便学习一个ES5的方法,可以获得对象的原型console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。举个例子：12345678910111213function Person() &#123;&#125;Person.prototype.name = &apos;Kevin&apos;;var person = new Person();person.name = &apos;Daisy&apos;;console.log(person.name) // Daisydelete person.name;console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是：123var obj = new Object();obj.name = &apos;Kevin&apos;console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链那 Object.prototype 的原型呢？null，我们可以打印：1console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？引用阮一峰老师的 《undefined与null的区别》 就是：null 表示“没有对象”，即该处不应该有值。所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。所以查找属性的时候查到 Object.prototype 就可以停止查找了。最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充最后，补充三点大家可能不会注意的地方： constructor首先是 constructor 属性，我们看个例子：12345function Person() &#123;&#125;var person = new Person();console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：1person.constructor === Person.prototype.constructor #### proto其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是：继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>原型</tag>
        <tag>原型链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序的入门与理解]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%85%A5%E9%97%A8%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：1.app.js2.app.json3.app.wxss 而一个小程序页面由四个文件组成的1.js2.wxml3.wxss4.json 二、主文件的配置1.app.js 主要写全局js2.app.json 对小程序进行全局配置，决定页面文件的路径、窗口的显示情况、设置网络超时时间、设置多个tab等。 其中pages接收一个数组，并且每一项代表对应的页面的【路径+文件】，如果要新增一个页面，可以在这里面配置好保存，然后就会自动生成。3.app.wxss 待续……]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git常用命令总结（一）]]></title>
    <url>%2F2018%2F06%2F19%2Fgit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[经过一晚上的打滚，总结一下关于git的常用命令。(后期还会更新） 远程仓库与本地仓库关联123456789101112131415161718192021222324252627//一、进入.ssh文件夹。cd ~/.ssh //若没有.ssh文件夹，则使用如下命令创建：mkdir ~/.ssh //二、配置name和emailgit config --global user.name &quot;lkt&quot; git config --global user.email &quot;lkt@temp.com&quot; //将命令中的name和email换成自己的。//三、生成key。ssh-keygen -t rsa -C “lkt@temp.com” //按三次回车，最后在.ssh文件夹下得到id_rsa和id_rsa.pub两个文件。id_rsa中的内容便是私钥，id_rsa.pub中的内容便是公钥。到这里ssh key就生成完毕了。 找到本地的公钥后，登录github，打开setting-ssh keys中，进行配置公钥。之后再通过以下命令实现本地仓库与远程仓库的关联1git remote add origin 仓库地址 git 克隆1234567//在对别人代码进行克隆的时候，可以以下命令：git clone 仓库地址//要是想有选择地克隆对方分支的文件，用这个：git clone -b 分支名称 仓库地址 git add1234//有选择地addgit add + 想要提交的文件名 git add 添加多个文件时，多个文件名之间用空格隔开 创建本地新分支1234567891011git branch 分支名称git checkout 分支名称 //切换本地分支git push origin 分支名 //其中origin指的是远程的仓库git branch -a //查看项目分支们git branch -d 分支名称 //删除本地分支git push origin --delete 分支名称 //删除远程分支 创建gh-pages分支进行项目演示123456git checkout --orphan gh-pages git add . //添加文件到暂存区git commit -m &quot;This is add message&quot; //添加信息，并把暂存区的所有修改提交到分支git push origin 分支名称 //提交到远程分支 合并分支1git merge --no-ff 分支名称 以上是小弟今晚的整理内容，后期有总结还会继续更新。 在简书上看到关于git的多人合作和分支管理，感觉写得很好，有兴趣可以看：传送们]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[json-xml学习笔记]]></title>
    <url>%2F2018%2F06%2F11%2Fjson-xml%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[我们先来说说json与xml的区别： （1）可读性方面：基本相同，XML的可读性比较好； （2）可扩展性方面：都具有良好的扩展性； （3）编码难度方面：相对而言，JSON的编码比较容易； （4）解码难度：JSON的解码难度基本为零，XML需要考虑子节点和父节点； （5）数据体积方面：JSON相对于XML来讲，数据体积小，传递的速度比较快； （6）数据交互方面：JSON与javascript的交互更加方便，更容易解析处理，更好的数据交互； （7）数据描述方面：XML对数据描述性比较好； （8）传输速度方面：JSON的速度远远快于XML。 一、json学习笔记json的一个简单例子1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125;]&#125; json的语法规则1、数据在名称/值对中 2、数据由逗号分隔 3、花括号保存对象 4、方括号保存数组 json 名称/值对1&quot;firstName&quot; : &quot;John&quot; json可以包含多个名称和键值对1&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125; json的数组1234567&#123;&quot;employees&quot;: [&#123; &quot;firstName&quot;:&quot;John&quot; , &quot;lastName&quot;:&quot;Doe&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Anna&quot; , &quot;lastName&quot;:&quot;Smith&quot; &#125;,&#123; &quot;firstName&quot;:&quot;Peter&quot; , &quot;lastName&quot;:&quot;Jones&quot; &#125;]&#125; 把 JSON 文本转换为 JavaScript 对象（1）创建包含json语法的javascript字符串1234var txt = &apos;&#123; &quot;employees&quot; : [&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; &#125;,&apos; +&apos;&#123; &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; &#125; ]&#125;&apos;; （2）使用eval（）函数由于 JSON 语法是 JavaScript 语法的子集，JavaScript 函数 eval() 可用于将 JSON 文本转换为 JavaScript 对象。 eval() 函数使用的是 JavaScript 编译器，可解析 JSON 文本，然后生成 JavaScript 对象。必须把文本包围在括号中，这样才能避免语法错误：1var obj = eval (&quot;(&quot; + txt + &quot;)&quot;); 在网页中使用 JavaScript 对象：123456789&lt;p&gt;First Name: &lt;span id=&quot;fname&quot;&gt;&lt;/span&gt;&lt;br /&gt;Last Name: &lt;span id=&quot;lname&quot;&gt;&lt;/span&gt;&lt;br /&gt;&lt;/p&gt;&lt;script type=&quot;text/javascript&quot;&gt;document.getElementById(&quot;fname&quot;).innerHTML = obj.employees[1].firstNamedocument.getElementById(&quot;lname&quot;).innerHTML = obj.employees[1].lastName&lt;/script&gt; 二、xml学习笔记一个XML文档实例1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;note&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;&lt;/note&gt; XML 文档形成一种树结构XML 文档必须包含根元素。该元素是所有其他元素的父元素。 XML 文档中的元素形成了一棵文档树。这棵树从根部开始，并扩展到树的最底端。 所有元素均可拥有子元素：12345&lt;root&gt; &lt;child&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 上图表示下面的 XML 中的一本书：1234567891011121314151617181920&lt;bookstore&gt;&lt;book category=&quot;COOKING&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Everyday Italian&lt;/title&gt; &lt;author&gt;Giada De Laurentiis&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;30.00&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;CHILDREN&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt; &lt;/book&gt;&lt;book category=&quot;WEB&quot;&gt; &lt;title lang=&quot;en&quot;&gt;Learning XML&lt;/title&gt; &lt;author&gt;Erik T. Ray&lt;/author&gt; &lt;year&gt;2003&lt;/year&gt; &lt;price&gt;39.95&lt;/price&gt; &lt;/book&gt;&lt;/bookstore&gt; 例子中的根元素是 。文档中的所有 元素都被包含在 中。 元素有 4 个子元素：、&lt; author&gt;、、。 xml语法规则1、所有 XML 元素都须有关闭标签2、XML 标签对大小写敏感3、XML 必须正确地嵌套4、XML 文档必须有根元素5、XML 的属性值须加引号1234&lt;note date=&quot;08/08/2008&quot;&gt;&lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;/note&gt; 6、实体引用在 XML 中，一些字符拥有特殊的意义。 如果你把字符 “&lt;” 放在 XML 元素中，会发生错误，这是因为解析器会把它当作新元素的开始。 这样会产生 XML 错误：在 XML 中，有 5 个预定义的实体引用：7、XML 中的注释在 XML 中编写注释的语法与 HTML 的语法很相似：1&lt;!-- This is a comment --&gt; 8、在 XML 中，空格会被保留 xml命名规则(1.) 名称可以含字母、数字以及其他的字符(2.) 名称不能以数字或者标点符号开始(3.) 名称不能以字符 “xml”（或者 XML、Xml）开始(4.) 名称不能包含空格 XMLHttpRequest 对象什么是 XMLHttpRequest 对象？XMLHttpRequest 对象用于在后台与服务器交换数据。 XMLHttpRequest 对象是开发者的梦想，因为您能够： 在不重新加载页面的情况下更新网页在页面已加载后从服务器请求数据在页面已加载后从服务器接收数据在后台向服务器发送数据 1、创建 XMLHttpRequest 对象所有现代浏览器 (IE7+、Firefox、Chrome、Safari 以及 Opera) 都内建了 XMLHttpRequest 对象。 通过一行简单的 JavaScript 代码，我们就可以创建 XMLHttpRequest 对象。123xmlhttp=new XMLHttpRequest();老版本的 Internet Explorer （IE5 和 IE6）使用 ActiveX 对象：xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); 一个实例:12345678910111213141516171819202122232425262728293031323334353637383940&lt;script type=&quot;text/javascript&quot;&gt;var xmlhttp;function loadXMLDoc(url)&#123;xmlhttp=null;if (window.XMLHttpRequest) &#123;// code for all new browsers xmlhttp=new XMLHttpRequest(); &#125;else if (window.ActiveXObject) &#123;// code for IE5 and IE6 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;if (xmlhttp!=null) &#123; xmlhttp.onreadystatechange=state_Change; xmlhttp.open(&quot;GET&quot;,url,true); xmlhttp.send(null); &#125;else &#123; alert(&quot;Your browser does not support XMLHTTP.&quot;); &#125;&#125;function state_Change()&#123;if (xmlhttp.readyState==4) &#123;// 4 = &quot;loaded&quot; if (xmlhttp.status==200) &#123;// 200 = OK // ...our code here... &#125; else &#123; alert(&quot;Problem retrieving XML data&quot;); &#125; &#125;&#125;&lt;/script&gt; xml解析器1、通用方法:123456789101112if (window.XMLHttpRequest) &#123;// code for IE7+, Firefox, Chrome, Opera, Safari xmlhttp=new XMLHttpRequest(); &#125;else &#123;// code for IE6, IE5 xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); &#125;xmlhttp.open(&quot;GET&quot;,&quot;books.xml&quot;,false);xmlhttp.send();xmlDoc=xmlhttp.responseXML; 2、通过微软的 XML 解析器来加载 XML微软的 XML 解析器内建于 Internet Explorer 5 以及更高的版本中。123var xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;);xmlDoc.async=&quot;false&quot;;xmlDoc.load(&quot;note.xml&quot;); 3、在 Firefox 及其他浏览器中的 XML 解析器下面的 JavaScript 片段把 XML 文档 (“note.xml”) 载入解析器：123var xmlDoc=document.implementation.createDocument(&quot;&quot;,&quot;&quot;,null);xmlDoc.async=&quot;false&quot;;xmlDoc.load(&quot;note.xml&quot;); 4、解析 XML 字符串1234567891011121314151617txt=&quot;&lt;bookstore&gt;&lt;book&gt;&quot;;txt=txt+&quot;&lt;title&gt;Everyday Italian&lt;/title&gt;&quot;;txt=txt+&quot;&lt;author&gt;Giada De Laurentiis&lt;/author&gt;&quot;;txt=txt+&quot;&lt;year&gt;2005&lt;/year&gt;&quot;;txt=txt+&quot;&lt;/book&gt;&lt;/bookstore&gt;&quot;;if (window.DOMParser) &#123; parser=new DOMParser(); xmlDoc=parser.parseFromString(txt,&quot;text/xml&quot;); &#125;else // Internet Explorer &#123; xmlDoc=new ActiveXObject(&quot;Microsoft.XMLDOM&quot;); xmlDoc.async=&quot;false&quot;; xmlDoc.loadXML(txt); &#125; xml DOMXML DOM (XML Document Object Model) 定义了访问和操作 XML 文档的标准方法。 DOM 把 XML 文档作为树结构来查看。能够通过 DOM 树来访问所有元素。可以修改或删除它们的内容，并创建新的元素。元素，它们的文本，以及它们的属性，都被认为是节点。 在下面的例子中，我们使用 DOM 引用从 元素中获取文本：1xmlDoc.getElementsByTagName(&quot;to&quot;)[0].childNodes[0].nodeValue xmlDoc -由解析器创建的 XML 文档getElementsByTagName(“to”)[0] - 第一个 元素childNodes[0] - 元素的第一个子元素（文本节点）nodeValue - 节点的值（文本本身） 关于XML HttpRequest的状态码readyState有五种状态： 0 (未初始化)： (XMLHttpRequest)对象已经创建，但还没有调用open()方法； 1 (载入)：已经调用open() 方法，但尚未发送请求； 2 (载入完成)： 请求已经发送完成； 3 (交互)：可以接收到部分响应数据； 4 (完成)：已经接收到了全部数据，并且连接已经关闭。 status实际是一种辅状态判断，只是status更多是服务器方的状态判断。 关于status，由于它的状态有几十种，我只列出平时常用的几种： 1xx——信息类，表示收到Web浏览器请求，正在进一步的处理中。如，100：客户必须继续发出请求；101：客户要求服务器根据请求转换HTTP协议版本 2xx——成功，表示用户请求被正确接收，理解和处理。例如，200：OK；201：提示知道新文件的URL 3xx——重定向，表示请求没有成功，客户必须采取进一步的动作。如，300：请求的资源可在多处得到；301：删除请求数据 4xx——客户端错误，表示客户端提交的请求有错误。如，404：NOT Found，意味着请求中所引用的文档不存在。 5xx——服务器错误，表示服务器不能完成对请求的处理。如，500，服务器产生内部错误]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>数据传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】全面理解Javascript闭包和闭包的几种写法及用途]]></title>
    <url>%2F2018%2F06%2F06%2F%E3%80%90%E8%BD%AC%E3%80%91%E5%85%A8%E9%9D%A2%E7%90%86%E8%A7%A3Javascript%E9%97%AD%E5%8C%85%E5%92%8C%E9%97%AD%E5%8C%85%E7%9A%84%E5%87%A0%E7%A7%8D%E5%86%99%E6%B3%95%E5%8F%8A%E7%94%A8%E9%80%94%2F</url>
    <content type="text"><![CDATA[一、什么是闭包和闭包的几种写法和用法1、什么是闭包 闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点： 1. 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 2. 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 简单的说，Javascript允许使用内部函数—即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 2、闭包的几种写法和用法 首先要明白，在JS中一切都是对象，函数是对象的一种。下面先来看一下闭包的5种写法，简单理解一下什么是闭包。后面会具体解释。 1234567891011//第1种写法 function Circle(r) &#123; this.r = r; &#125; Circle.PI = 3.14159; Circle.prototype.area = function() &#123; return Circle.PI * this.r * this.r; &#125; var c = new Circle(1.0); alert(c.area()); 这种写法没什么特别的，只是给函数添加一些属性。 12345678910111213//第2种写法 var Circle = function() &#123; var obj = new Object(); obj.PI = 3.14159; obj.area = function( r ) &#123; return this.PI * r * r; &#125; return obj; &#125; var c = new Circle(); alert( c.area( 1.0 ) ); 这种写法是声明一个变量，将一个函数当作值赋给变量。 12345678//第3种写法 var Circle = new Object(); Circle.PI = 3.14159; Circle.Area = function( r ) &#123; return this.PI * r * r; &#125; alert( Circle.Area( 1.0 ) ); 这种方法最好理解，就是new 一个对象，然后给对象添加属性和方法。 12345678//第4种写法 var Circle=&#123; &quot;PI&quot;:3.14159, &quot;area&quot;:function(r)&#123; return this.PI * r * r; &#125; &#125;; alert( Circle.area(1.0) ); 这种方法使用较多，也最为方便。var obj = {}就是声明一个空的对象。1234//第5种写法 var Circle = new Function(&quot;this.PI = 3.14159;this.area = function( r ) &#123;return r*r*this.PI;&#125;&quot;); alert( (new Circle()).area(1.0) ); 说实话，这种写法我是没用过，大家可以参考一下。 总的来说，上面几种方法，第2中和第4中较为常见，大家可以根据习惯选择。 上面代码中出现了JS中常用的Prototype，那么Prototype有什么用呢？下面我们来看一下： 1234567891011121314151617var dom = function()&#123; &#125;;dom.Show = function()&#123; alert(&quot;Show Message&quot;);&#125;;dom.prototype.Display = function()&#123; alert(&quot;Property Message&quot;);&#125;;dom.Display(); //errordom.Show(); var d = new dom();d.Display();d.Show(); //error 我们首先声明一个变量，将一个函数赋给他，因为在Javascript中每个函数都有一个Portotype属性，而对象没有。添加两个方法，分别直接添加和添加打破Prototype上面，来看下调用情况。分析结果如下： 1、不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！ 2、使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！ 下面我们再来看一段代码： 12345678910var dom = function()&#123; var Name = &quot;Default&quot;; this.Sex = &quot;Boy&quot;; this.success = function()&#123; alert(&quot;Success&quot;); &#125;; &#125;; alert(dom.Name); alert(dom.Sex); 大家先看看，会显示什么呢？ 答案是两个都显示Undefined,为什么呢？这是由于在Javascript中每个function都会形成一个作用域，而这些变量声明在函数中，所以就处于这个函数的作用域中，外部是无法访问的。要想访问变量，就必须new一个实例出来。 123456789var html = &#123; Name:&apos;Object&apos;, Success:function()&#123; this.Say = function()&#123; alert(&quot;Hello,world&quot;); &#125;; alert(&quot;Obj Success&quot;); &#125; &#125;; 再来看看这种写法，其实这是Javascript的一个”语法糖”，这种写法相当于： 1234567var html = new Object();html.Name = &apos;Object&apos;;html.Success = function()&#123; this.Say = function()&#123; alert(&quot;Hello,world&quot;); &#125;; alert(&quot;Obj Success&quot;); 变量html是一个对象，不是函数，所以没有Prototype属性，其方法也都是公有方法，html不能被实例化。否则会出现如下错误： 但是他可以作为值赋给其它变量，如var o = html; 我们可以这样使用它： alert(html.Name); html.Success(); 说到这里，完了吗？细心的人会问，怎么访问Success方法中的Say方法呢？是html.Success.Say()吗？ 当然不是，上面刚说过由于作用域的限制，是访问不到的。所以要用下面的方法访问： 123456789var s = new html.Success();s.Say();//还可以写到外面html.Success.prototype.Show = function()&#123; alert(&quot;HaHa&quot;);&#125;;var s = new html.Success();s.Show(); 关于Javascript作用域的问题，不是一两句能说清楚的，有兴趣的大家可以网上找些资料看看。 二、Javascript闭包的用途事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。 1、匿名自执行函数 我们知道所有的变量，如果不加上var关键字，则默认的会添加到全局对象的属性上去，这样的临时变量加入全局对象有很多坏处，比如：别的函数可能误用这些变量；造成全局对象过于庞大，影响访问速度(因为变量的取值是需要从原型链上遍历的)。除了每次使用变量都是用var关键字外，我们在实际情况下经常遇到这样一种情况，即有的函数只需要执行一次，其内部变量无需维护，比如UI的初始化，那么我们可以使用闭包： 1234567891011121314var data= &#123; table : [], tree : &#123;&#125; &#125;; (function(dm)&#123; for(var i = 0; i &lt; dm.table.rows; i++)&#123; var row = dm.table.rows[i]; for(var j = 0; j &lt; row.cells; i++)&#123; drawCell(i, j); &#125; &#125; &#125;)(data); 我们创建了一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在函数执行完后会立刻释放资源，关键是不污染全局对象。 2、结果缓存 我们开发中会碰到很多情况，设想我们有一个处理过程很耗时的函数对象，每次调用都会花费很长时间， 那么我们就需要将计算出来的值存储起来，当调用这个函数的时候，首先在缓存中查找，如果找不到，则进行计算，然后更新缓存并返回值，如果找到了，直接返回查找到的值即可。闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。 12345678910111213141516171819202122232425var CachedSearchBox = (function()&#123; var cache = &#123;&#125;, count = []; return &#123; attachSearchBox : function(dsid)&#123; if(dsid in cache)&#123;//如果结果在缓存中 return cache[dsid];//直接返回缓存中的对象 &#125; var fsb = new uikit.webctrl.SearchBox(dsid);//新建 cache[dsid] = fsb;//更新缓存 if(count.length &gt; 100)&#123;//保正缓存的大小&lt;=100 delete cache[count.shift()]; &#125; return fsb; &#125;, clearSearchBox : function(dsid)&#123; if(dsid in cache)&#123; cache[dsid].clearSelection(); &#125; &#125; &#125;; &#125;)(); CachedSearchBox.attachSearchBox(&quot;input&quot;); 这样我们在第二次调用的时候，就会从缓存中读取到该对象。 3、封装 123456789101112131415161718192021222324var person = function()&#123; //变量作用域为函数内部，外部无法访问 var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;(); print(person.name);//直接访问，结果为undefined print(person.getName()); person.setName(&quot;abruzzi&quot;); print(person.getName()); 得到结果如下： undefined default abruzzi 4、实现类和继承 12345678910111213141516171819202122232425262728function Person()&#123; var name = &quot;default&quot;; return &#123; getName : function()&#123; return name; &#125;, setName : function(newName)&#123; name = newName; &#125; &#125; &#125;; var p = new Person(); p.setName(&quot;Tom&quot;); alert(p.getName()); var Jack = function()&#123;&#125;; //继承自Person Jack.prototype = new Person(); //添加私有方法 Jack.prototype.Say = function()&#123; alert(&quot;Hello,my name is Jack&quot;); &#125;; var j = new Jack(); j.setName(&quot;Jack&quot;); j.Say(); alert(j.getName()); 我们定义了Person，它就像一个类，我们new一个Person对象，访问它的方法。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack初体验]]></title>
    <url>%2F2018%2F06%2F02%2Fwebpack%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[如今，越来越多的JavaScript代码被使用在页面上，我们添加很多的内容在浏览器里。如何去很好的组织这些代码，成为了一个必须要解决的难题。 对于模块的组织，通常有如下几种方法： 通过书写在不同文件中，使用script标签进行加载CommonJS进行加载（NodeJS就使用这种方式）AMD进行加载（require.js使用这种方式）ES6模块 思考：为什么只有JS需要被模块化管理，前台的很多预编译内容，不需要管理吗？ 基于以上的思考，WebPack项目有如下几个目标： 1、将依赖树拆分，保证按需加载2、保证初始加载的速度3、所有静态资源可以被模块化4、可以整合第三方的库和模块5、可以构造大系统6、从下图可以比较清晰的看出WebPack的功能 这是一个示意图WebPack的特点1、丰富的插件，方便进行开发工作2、大量的加载器，包括加载各种静态资源3、代码分割，提供按需加载的能力4、发布工具 WebPack的优势webpack 是以 commonJS 的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。能被模块化的不仅仅是 JS 了。开发便捷，能替代部分 grunt/gulp 的工作，比如打包、压缩混淆、图片转base64等。扩展性强，插件机制完善，特别是支持 React 热插拔（见 react-hot-loader ）的功能让人眼前一亮。 WebPack的安装安装命令1$ npm install webpack -g 使用webpack12$ npm init # 会自动生成一个package.json文件$ npm install webpack --save-dev #将webpack增加到package.json文件中 可以使用不同的版本1$ npm install webpack@1.2.x --save-dev 如果想要安装开发工具1$ npm install webpack-dev-server --save-dev WebPack的配置每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 下面是一个例子12345678910111213141516171819202122232425262728293031323334353637var webpack = require(&apos;webpack&apos;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : &apos;./src/js/page/index.js&apos; &#125;, //入口文件输出配置 output: &#123; path: &apos;dist/js/page&apos;, filename: &apos;[name].js&apos; &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;, &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;, &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125; ] &#125;, //其它解决方案配置 resolve: &#123; //查找module的话从这里开始查找 root: &apos;E:/github/flux-example/src&apos;, //绝对路径 //自动扩展文件后缀名，意味着我们require模块可以省略不写后缀名 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;], //模块别名定义，方便后续直接引用别名，无须多写长长的地址 alias: &#123; AppStore : &apos;js/stores/AppStores.js&apos;, ActionType : &apos;js/actions/ActionType.js&apos;, AppAction : &apos;js/actions/AppAction.js&apos; &#125; &#125;&#125;; plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。entry 是页面入口文件配置，output 是对应输出项配置 （即入口文件最终要生成什么名字的文件、存放到哪里）module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。 所有加载器需要使用npm来加载最后是 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写） WebPack开始使用这里有最基本的使用方法，给大家一个感性的认识 正确安装了WebPack，方法可以参考上面书写entry.js文件12345678910document.write(&quot;看看如何让它工作！&quot;);书写index.html文件&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 执行命令，生成bundle.js文件$ webpack ./entry.js bundle.js在浏览器中打开index.html文件，可以正常显示出预期增加一个content.js文件module.exports = “现在的内容是来自于content.js文件！”;修改entry.js文件1document.write(require(&quot;./content.js&quot;)); 执行第四步的命令进行加载器试验 增加style.css文件123body &#123; background: yellow;&#125; 修改entry.js文件12require(&quot;!style-loader!css-loader!./style.css&quot;);document.write(require(&quot;./content.js&quot;)); 执行命令，安装加载器1$ npm install css-loader style-loader # 安装的时候不使用 -g 执行webpack命令，运行看效果可以在命令行中使用loader1$ webpack ./entry.js bundle.js --module-bind &quot;css=style-loader!css-loader&quot; 使用配置文件默认的配置文件为webpack.config.js 增加webpack.config.js文件123456789101112module.exports = &#123; entry: &quot;./entry.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &quot;style-loader!css-loader&quot; &#125; ] &#125;&#125;; 执行程序1$ webpack 发布服务器 安装服务器12$ npm install webpack-dev-server -g$ webpack-dev-server --progress --colors 服务器可以自动生成和刷新，修改代码保存后自动更新画面http://localhost:8080/webpack-dev-server/bundle WebPack常用命令$ webpack –display-error-details后面的参数“–display-error-details”是推荐加上的，方便出错时能查阅更详尽的信息（比如 webpack 寻找模块的过程），从而更好定位到问题。1234$ webpack --config XXX.js //使用另一份配置文件（比如webpack.config2.js）来打包$ webpack --watch //监听变动并自动打包$ webpack -p //压缩混淆脚本，这个非常非常重要！$ webpack -d //生成map映射文件，告知哪些模块被最终打包到哪里了 作者：hutou來源：简书]]></content>
      <categories>
        <category>模块打包器</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解浮动以及解决浮动带来的问题]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%90%86%E8%A7%A3%E6%B5%AE%E5%8A%A8%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%B5%AE%E5%8A%A8%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[要解决浮动带来的各种问题，首先我们得了解浮动的特点和造成的问题，方能对症下药。 一、浮动的特点在CSS2.1 规范中，对浮动的解释如下： A float is a box that is shifted to the left or right on the current line. A floated box is shifted to the left or right until its outer edge touches the containing block edge or the outer edge of another float. If there is a line box, the outer top of the floated box is aligned with the top of the current line box. If there is not enough horizontal room for the float, it is shifted downward until either it fits or there are no more floats present. 浮动元素脱离文档流，在当前行的左边或是右边对齐，如果当前行没有足够的空间，它将下移一行，直到有足够的空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 二、浮动造成的问题（1）父元素的高度无法被撑开 关于这个一点，就不演示了。 （2）浮动元素前同级非浮动元素： 若为：行内元素 当行内元素被撑起的宽度加上浮动元素的宽度，大于父元素的宽度时，浮动元素，就会下移一个line-height，直到计算的值小于父元素的宽度时，非浮动元素会跟随其后，如下： 123456789&lt;div style=&quot; height:500px;background-color:#0f0&quot;&gt; &lt;span style=&quot;background-color:#ff0; line-height:35px;&quot; &gt; 浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离 &lt;/span&gt; &lt;div style=&quot;width:100px; height:500px;background-color:#f00; float:left; display:-inline-block&quot; &gt; &lt;/div&gt; &lt;/div&gt; 若为：块内元素 浮动元素会在块内元素下一行进行浮动。 123456789&lt;div style=" height:500px;background-color:#0f0"&gt; &lt;div style="line-height:35px;" &gt; 浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离浮动元素脱离文档流，向左或是向右浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离,浮动，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留,浮动元素脱离 &lt;/div&gt; &lt;div style="width:100px; height:500px;background-color:#f00; float:left;" &gt; &lt;/div&gt; &lt;/div&gt; （3）浮动元素后同级非浮动元素： 无论是行内元素，还是块内元素，都会会紧随浮动元素之后，也就是说同一水平的line boxes都被压缩了，这也是文字环绕图片的原因。但是从黄色边框的div的位置可以看出，其在定位上，并没有受到浮动元素的影响。具体效果如下： 1234567891011121314&lt;div style="background-color:#0f0; border:5px solid #000; padding:10px"&gt; 黑色表框为最外层包裹元素 &lt;div style="width:100px; height:500px;border:1px solid #F00; float:left; color:#F00" &gt; 红色边框的为左浮动元素 &lt;/div&gt; &lt;div style="line-height:35px; width:800px;border:5px solid #FF0; min-height:200px; color:#FF0" &gt; 黄色表框的为这是块内元素 &lt;/div&gt; &lt;span style="line-height:35px; border:5px solid #F0F; color:#F0F" &gt; 黄色表框的为这是行内元素 &lt;/span&gt; &lt;/div&gt; （4）浮动元素对浮动元素的影响 同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面，当空间不够时会被挤下。 反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下。如下： 123456789&lt;div style="background-color:#00f;"&gt; &lt;div style="border:1px solid #F00; width:200px; height:100px;float:left; margin-bottom:5px;"&gt; 浮动box 1 &lt;/div&gt; &lt;/div&gt; &lt;div style="border:1px solid #F00; width:200px; height:100px;float:left; margin-bottom:5px;"&gt; 浮动box 2 &lt;/div&gt; 三、浮动的解决办法目前关于浮动问题的解决办法主要由以下两种： 一是利用 clear 属性，包括在浮动元素末尾添加一个带有 clear: both 属性的空 div 来闭合元素，其实利用 :after 伪元素的方法也是在元素末尾添加一个内容为一个点并带有 clear: both 属性的元素实现的。如： ①在浮动的元素后面添加一个能构成block-level boxes元素，设置style=”clear:both;”； ②给浮动的父元素添加一个:after伪元素。 1234567891011121314.clearFloat:after &#123; content:""; /*设置该区域的内容*/ display:block; /*把该区域转为block-level boxes 因为clear对该类型的box有效，伪元素:before和:after添加的内容默认是inline元素*/ clear:both; /*清除浮动*/ visibility: hidden; /*不显示该区域,其实上面设置了content为空，这一行可以省略*/ &#125; /*bootstratp3.1.0 中 解决浮动问题的*/ .clearfix:before,.clearfix:after&#123; display: table; content: " " &#125; .clearfix:after&#123; clear: both; &#125; 有的时候，为了兼容IE，还得添加一个.clearfix{*zoom:1}。为什么要使用到before呢？这个是防止margin折叠的，关于margin折叠，可以查看css手册8.3.1 Collapsing margins 二是：利用BFC (Block Formatting Contexts, 块级格式化上下文)特性：:BFC就是页面上的一个隔离的独立容器，不会与其他Box发生折叠（即使元素浮动），容器里面的子元素不会影响到外面的元素，反之也如此。关于这一点，可以“理解CSS中的BFC块级格式化上下文”。如下： 12345div style="background-color:#00f; display:table"&gt; &lt;div style=" width:200px; height:50px; float:left; border:1px solid #f00; "&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style="border:1px solid #0Ff ;width:200px; height:50px; margin-top:15px; float:left;"&gt;&lt;/div&gt; 浮动的父元素，通过设置display等于table（当然“理解CSS中的BFC块级格式化上下文”里，还有其他很多方式哦），拥有了BFC，就能解决浮动塌方问题，同时也解决了浮动元素对浮动元素的影响。由于创建BFC方式来解决浮动带来的问题，往往会改变父元素的某些特性，在实际开发中，采用的不是很多。]]></content>
      <categories>
        <category>浮动问题</category>
      </categories>
      <tags>
        <tag>float</tag>
        <tag>浮动问题</tag>
      </tags>
  </entry>
</search>
